<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html  xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<!-- generated by to_html.pl from ReadUnread.xml -->
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<title>未读/已读处理说明</title>
	<meta name="author" content="W.Dee" />
	<meta http-equiv="Content-Style-Type" content="text/css" />
	<meta http-equiv="Content-Script-Type" content="text/javascript" />
	<link href="browser.css" type="text/css" rel="stylesheet" title="吉里吉里相关参考用标准样式" />
	<link href="mailto:dee@kikyou.info" rev="Made" />
	<link href="index.html" target="_top" rel="Start" title="首页" />
</head>
<body>
<h1><a id="id179" name="id179">未读/已读处理</a>
</h1><div class="para"><div>
　未读是指用户尚未阅读过剧本，已读是指用户已经阅读过。<br />
　KAG 可以根据未读部分和已读部分来改变消息的显示速度，或者在已读部分禁用 [l] 标签等。<br />
<br />
　未读/已读的记录保存在以 <code class="inlinecode">trail_</code> 开头的系统变量中。要进行未读/已读记录，需要将 <code class="inlinecode">Config.tjs</code> 中的 <code class="inlinecode">autoRecordPageShowing</code> 设置为 true。<br />
</div></div>
<h1><a id="id180" name="id180">未读部分和已读部分</a>
</h1><div class="para"><div>
　在KAG中，未读部分/已读部分是以标签为标记进行区分的。<br />
　记录在 <code class="inlinecode">trail_剧本文件名_标签</code> 这种格式的系统变量中。例如，first.ks 中的 *start 标签，就对应变量名 <code class="inlinecode">sf.trail_first_start</code>。<br />
　如果这个变量是 void（即未定义；与数值比较时视为 0），则为未读，如果是 1 或更大的数值，则为已读。1以上的值表示该部分被阅读的次数。<br />
<br />
　基本上，从一个标签到下一个标签或 [s] 标签之间的内容被视为一个"部分"。<br />
　例如，如果有以下剧本，每种颜色区分的剧本就是各个部分。<br />
<br />
<table width="100%">

<tr><td bgcolor="#ffc0c0"><span class="script">

*部分其1<br />

@cm<br />

这里是部分其1。[l][r]<br />

通常情况下，到下一个标签为止视为一个"部分"。[p][r]<br />

</span></td></tr>

<tr><td bgcolor="#c0ffc0"><span class="script">

*部分其2<br />

@cm<br />

这里是部分其2。[p][r]<br />

</span></td></tr>

<tr><td bgcolor="#c0c0ff"><span class="script">

*部分其3<br />

@cm<br />

这里是部分其3。[l][r]<br />

到[s]标签为止也视为一个"部分"。[s]<br />

</span></td></tr>

</table>
<br />
　未读已读处理是以这个"部分"为单位进行的。<br />
<br />
　初始状态下所有部分都被视为未读。<br />
</div></div>
<h1><a id="id181" name="id181">已读判定</a>
</h1><div class="para"><div>
　这些"部分"被视为已读有一定条件。原则上，"到达下一个标签或[s]标签"时，该"部分"才被视为已读，并记录在系统变量中。<br />
　也就是说，如果用户在"部分"中途结束程序或停止阅读，则不会被视为已读。必须将该"部分"读完才算。<br />
</div></div>
<h1><a id="id182" name="id182">剧本控制与已读判定</a>
</h1><div class="para"><div>
　如果中途有链接或jump标签等导致剧本分支，处理方式会有所不同。<br />
<br />
<dl>
<dt>通过链接类（link或button标签）跳转的情况</dt>
<dd>　当用户通过这些标签选择选项并跳转到剧本的其他部分时，会自动标记为已读。<br />
　例如以下例子中，<br />

<br />
<code class="bq">*select<br />
这部分内容，在用户选择选项时会被标记为已读。[r]<br />
[link&nbsp;target=*t1]选项1[endlink][r]<br />
[link&nbsp;target=*t2]选项2[endlink][r]<br />
@wait&nbsp;time=3000<br />
@jump&nbsp;target=*timeout<br />
</code>
<br />

　如果在@wait标签超时前选择了选项，那么此时就会被标记为已读。顺便说一下，在通常的选项使用方式中，link标签显示选项后通常会跟着[s]标签，所以在那个时点就会标记为已读。<br />
　link标签和button标签有一个叫contpage的属性，将其设为false时，即使在那个时点进行跳转也不会被标记为已读。<br />
</dd>
<dt>jump标签</dt>
<dd>　使用jump标签进行跳转时，也会在那个时点被标记为已读。这种情况下也有一个叫contpage的属性，将其设为false时不会被标记为已读。<br />
</dd>
<dt>call和return</dt>
<dd>　使用call标签调用子程序时不会被标记为已读。这种情况下也有一个叫contpage的属性，将其设为true时，在那个时点会被标记为已读。<br />
　return标签在那个时点会被标记为已读（不是调用方被标记为已读，而是子程序中有return标签的那部分被标记为已读）。这种情况下也有一个叫contpage的属性，将其设为false时不会被标记为已读。<br />
</dd></dl></div></div>
	<script type="text/javascript" charset="UTF-8" src="documentid.js" ></script>
	<script type="text/javascript" charset="UTF-8" src="postcontent.js" ></script>
</body>
</html>
