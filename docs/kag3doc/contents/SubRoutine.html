<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html  xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<!-- generated by to_html.pl from SubRoutine.xml -->
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<title>让我们使用子程序</title>
	<meta name="author" content="W.Dee" />
	<meta http-equiv="Content-Style-Type" content="text/css" />
	<meta http-equiv="Content-Script-Type" content="text/javascript" />
	<link href="browser.css" type="text/css" rel="stylesheet" title="吉里吉里相关参考用标准样式" />
	<link href="mailto:dee@kikyou.info" rev="Made" />
	<link href="index.html" target="_top" rel="Start" title="首页" />
</head>
<body>

<h1><a id="id196" name="id196">什么是子程序</a>
</h1><div class="para"><div>
　子程序是将多个处理过程组合在一起，通过从其他地方"调用"来使用的东西。当子程序的处理结束后，控制权会返回到调用处。<br />
<br />
　宏 <span class="comlink"> ( → <a target="main" class="jump" href="Macro.html">让我们使用宏</a> ) </span> 的功能与之相似，但子程序用于执行更加正式的处理，而宏则用于执行简单的处理。<br />
</div></div>
<h1><a id="id197" name="id197">子程序的基本用法</a>
</h1><div class="para"><div>
　子程序通过标签进行区分，所以需要定义标签。从子程序返回到调用处使用 <a id="id198" name="id198" class="targanchor"><dfn>return</dfn></a> 标签，调用子程序则使用 <a id="id199" name="id199" class="targanchor"><dfn>call</dfn></a> 标签。<br />
　请看下面的例子。<br />

<br />
<code class="bq">[wait&nbsp;time=200]<br />
*start|开始<br />
[cm]<br />
调用子程序。[l][r]<br />
<em>[call&nbsp;target=*subroutine]</em><br />
子程序已被调用。<br />
[s]<br />
<br />
<em>*subroutine</em><br />
这是一个子程序。[l][r]<br />
点击将返回到调用处。[l][r]<br />
<em>[return]</em><br />
</code>
<br />

<br />
　现在，执行这个例子，在"调用子程序。"的消息之后会显示"这是一个子程序。"，然后在"点击将返回到调用处。"处点击后，会显示"子程序已被调用。"<br />
　也就是说，通过call标签跳转到指定的标签处，但此时调用位置会自动被记录，return标签会自动返回到这个记录的调用处（这个自动记录的东西被称为"<a id="id200" name="id200" class="targanchor"><dfn>调用栈</dfn></a>"）。<br />
　在这个例子中，<code class="inlinecode">*subroutine</code> 到 <code class="inlinecode">[return]</code> 之间的部分就是"子程序"。<br />
<br />
　子程序中也可以调用其他子程序。调用的深度（在不使用return的情况下可以call多少次）没有限制。<br />
<br />
　顺便说一下，在"让我们使用选择肢"一节中提到标签后面要写[cm]，但如果不是作为保存点的（带有|的）标签，不写[cm]也是可以的。<br />
<br />
<br />
　调用栈只记录脚本文件名、脚本中的前一个标签以及从该标签到call标签所在行的行数、call标签所在行的内容以及在该行中的位置信息。在调试脚本时，如果返回目标的脚本文件结构发生变化，可能会返回到意想不到的位置，请注意这一点。<br />
　基本上，子程序的标签或子程序中最好不要使用/创建作为保存点的标签（带有|的标签）。<br />
</div></div>
<h1><a id="id201" name="id201">关于子程序的注意事项</a>
</h1><div class="para"><div>
　如果用call调用自身，会陷入无限循环。<br />
　如果call和return的对应关系不正确，调用栈会不断增加，或者在return标签处无法返回到调用处而导致错误，请注意这一点。<br />
<br />
　另外，像下面的例子那样<br />
<br />

<br />
<code class="bq">*subroutine<br />
・・・<br />
[if&nbsp;exp=&quot;f.flag1&quot;]<em>[jump&nbsp;target=*otherplaces1]</em>[endif]<br />
[if&nbsp;exp=&quot;f.flag2&quot;]<em>[jump&nbsp;target=*otherplaces2]</em>[endif]<br />
・・・<br />
[return]<br />
<br />
*otherplaces1<br />
・・・<br />
[return]<br />
<br />
*otherplaces2<br />
;这后面没有return标签・・・<br />
</code>
<br />

<br />
　在子程序中跳转到其他地方时要小心。跳转到otherplaces1的情况下，跳转目标处有return，所以不会破坏call～return的平衡。但是，跳转到otherplaces2的情况下，跳转后没有出现return，所以这个子程序"没有返回"。也就是说，破坏了call～return的平衡。<br />
<br />
　如果不想返回到调用处，而是想返回到任意位置，可以利用return标签的storage或target属性返回到任意位置。<br />
</div></div>
	<script type="text/javascript" charset="UTF-8" src="documentid.js" ></script>
	<script type="text/javascript" charset="UTF-8" src="postcontent.js" ></script>
</body>
</html>
