<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html  xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<!-- generated by to_html.pl from expr_and_op.xml -->
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<title>表达式和运算符</title>
	<meta name="author" content="W.Dee" />
	<meta http-equiv="Content-Style-Type" content="text/css" />
	<meta http-equiv="Content-Script-Type" content="text/javascript" />
	<link href="browser.css" type="text/css" rel="stylesheet" title="吉里吉里相关参考用标准样式" />
	<link href="mailto:dee@kikyou.info" rev="Made" />
	<link href="index.html" target="_top" rel="Start" title="首页" />
</head>
<body>
<h1><a id="id88" name="id88">表达式和运算符</a>
</h1><div class="para"><div>
　<a id="id89" name="id89" class="targanchor"><dfn>表达式</dfn></a>是运算符和操作数的集合，或者是即时值。<br />
<br />
　通常，可以在脚本中按以下方式描述。<br />
<br />
<code class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;表达式;<br />
</code><br />
　像这样在表达式后面加上分号，该表达式会在当场被评估(=执行)，其表达式的结果会被丢弃。<br />
<br />

<br />
<code class="bq"><span class="weak">例:</span><br />&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;b;<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;通过运算符&nbsp;=&nbsp;的操作，变量b被赋值给变量a</span><br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;func();<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;通过运算符&nbsp;(&nbsp;)&nbsp;的操作，func被作为函数调用，但函数的返回值</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;被丢弃</span><br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;+&nbsp;3;<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;通过&nbsp;+&nbsp;运算符的操作，1&nbsp;和&nbsp;3&nbsp;相加，但结果被丢弃(实际上这个</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;表达式没有意义，甚至不会被执行)</span><br />
</code>
<br />

</div></div>
<h1><a id="id90" name="id90">真和假</a>
</h1><div class="para"><div>
　一些运算符处理真或假(逻辑值)。运算结果为0时为假，非0时为真。<br />
　当对字符串询问真假时，如果是空字符串则为假，否则尝试转换为数值，转换成功则结果为该数值的真假，失败则为假。<br />
</div></div>
<h1><a id="id91" name="id91">运算符</a>
</h1><div class="para"><div>
　下面按优先级从低到高的顺序说明运算符。<br />
</div></div>

<h1><a id="id92" name="id92">if 运算符</a>
</h1><div class="para"><div>
　if 运算符 <code class="inlinecode">if</code> 是只有在右侧的表达式评估结果为真时，才会评估左侧表达式的运算符。<br />

<br />
<code class="bq"><span class="weak">例:</span><br />&nbsp;&nbsp;&nbsp;&nbsp;a=b&nbsp;if&nbsp;b!=0;&nbsp;<span class="comment">//&nbsp;如果b不为0，则将b赋值给a</span><br />
</code>
<br />

<br />
　无法获取运算符的结果。<br />
</div></div>
<h1><a id="id93" name="id93">顺序运算符</a>
</h1><div class="para"><div>
　顺序运算符 <code class="inlinecode"><a id="id94" name="id94" class="targanchor"><dfn>,</dfn></a></code> (逗号) 先评估左侧表达式，然后评估右侧表达式。除此之外不做任何操作。整个运算符的结果是右侧表达式的评估结果。当多个逗号连续写入时，会从左到右依次评估。<br />

<br />
<code class="bq"><span class="weak">例:</span><br />&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;(a=1,&nbsp;b=2);&nbsp;<span class="comment">//&nbsp;a=1,&nbsp;b=2被评估，c被赋值为2</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;a=1,&nbsp;b=2,&nbsp;c=3;&nbsp;<span class="comment">//&nbsp;按a=1,&nbsp;b=2,&nbsp;c=3的顺序评估</span><br />
</code>
<br />

</div></div>
<h1><a id="id95" name="id95">赋值运算符</a>
</h1><div class="para"><div>
　赋值运算符包括以下几种。<br />
<br />
<code class="inlinecode"><a id="id96" name="id96" class="targanchor"><dfn>=</dfn></a>  <a id="id97" name="id97" class="targanchor"><dfn>&lt;-&gt;</dfn></a>  <a id="id98" name="id98" class="targanchor"><dfn>&amp;=</dfn></a>  <a id="id99" name="id99" class="targanchor"><dfn>|=</dfn></a>  <a id="id100" name="id100" class="targanchor"><dfn>^=</dfn></a>  <a id="id101" name="id101" class="targanchor"><dfn>-=</dfn></a>  <a id="id102" name="id102" class="targanchor"><dfn>+=</dfn></a>  <a id="id103" name="id103" class="targanchor"><dfn>%=</dfn></a>  <a id="id104" name="id104" class="targanchor"><dfn>/=</dfn></a>  <a id="id105" name="id105" class="targanchor"><dfn>\=</dfn></a>  <a id="id106" name="id106" class="targanchor"><dfn>*=</dfn></a>  <a id="id107" name="id107" class="targanchor"><dfn>||=</dfn></a>  <a id="id108" name="id108" class="targanchor"><dfn>&amp;&amp;=</dfn></a>  <a id="id109" name="id109" class="targanchor"><dfn>&gt;&gt;=</dfn></a>  <a id="id110" name="id110" class="targanchor"><dfn>&lt;&lt;=</dfn></a>  <a id="id111" name="id111" class="targanchor"><dfn>&gt;&gt;&gt;=</dfn></a></code><br />
　其中，= 运算符是简单赋值运算符，将右侧表达式的评估结果赋值给左侧表达式，整个运算符的值为右侧表达式的评估结果。<br />

<br />
<code class="bq"><span class="weak">例:</span><br />&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;0;&nbsp;&nbsp;<span class="comment">//&nbsp;将0赋值给a</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;b&nbsp;=&nbsp;c&nbsp;=&nbsp;0;&nbsp;<span class="comment">//&nbsp;按c、b、a的顺序将0赋值</span><br />
</code>
<br />

<br />
　<code class="inlinecode">&lt;-&gt;</code> 运算符进行交换操作。首先评估左侧表达式，然后评估右侧表达式。之后，将右侧评估结果赋值给左侧，将左侧评估结果赋值给右侧。无法获取运算符的结果。<br />
　目前左右表达式分别会被评估<em>两次</em>，一次用于获取表达式值，一次用于赋值。将来此规范可能会改变，因此请不要编写依赖于评估次数的代码。<br />
<br />
　其他运算符都采用<code class="inlinecode">运算符=</code>的形式，当写作<code class="inlinecode">A 运算符= B</code>时，含义为<code class="inlinecode">A = A 运算符 B</code>。整个运算符的值为运算的结果值。<br />
</div></div>
<h1><a id="id112" name="id112">条件运算符</a>
</h1><div class="para"><div>
　条件运算符 <code class="inlinecode"><a id="id113" name="id113" class="targanchor"><dfn>? :</dfn></a></code> 是三元运算符。以<code class="inlinecode">A ? B : C</code>的形式编写时，先评估A，如果为真则评估B并忽略C；如果为假则评估C并忽略B。整个运算符的值为被评估的B或C的值。<br />
<br />
　条件运算符可以作为左值使用。<br />

<br />
<code class="bq"><span class="weak">例:</span><br />&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;b==0&nbsp;?&nbsp;c&nbsp;:&nbsp;b;&nbsp;<span class="comment">//&nbsp;如果b为0，则将c赋值给a；如果b不为0，则将b赋值给a</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;b==0&nbsp;?&nbsp;(a=c)&nbsp;:&nbsp;(a=b);&nbsp;<span class="comment">//&nbsp;与上面含义相同</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;(a&nbsp;?&nbsp;b&nbsp;:&nbsp;c&nbsp;)&nbsp;=&nbsp;d;&nbsp;<span class="comment">//&nbsp;如果a为真则将d赋值给b，如果a为假则将d赋值给c（作为左值使用的例子）</span><br />
</code>
<br />

</div></div>
<h1><a id="id114" name="id114">逻辑OR运算符</a>
</h1><div class="para"><div>
　逻辑OR运算符 <code class="inlinecode"><a id="id115" name="id115" class="targanchor"><dfn>||</dfn></a></code> 首先评估左侧表达式，如果为真则忽略右侧表达式，整个运算符结果为真。如果左侧表达式评估结果为假，则评估右侧表达式，其真假结果成为整个运算符的结果。<br />
</div></div>
<h1><a id="id116" name="id116">逻辑AND运算符</a>
</h1><div class="para"><div>
　逻辑AND运算符 <code class="inlinecode"><a id="id117" name="id117" class="targanchor"><dfn>&amp;&amp;</dfn></a></code> 首先评估左侧表达式，如果为假则忽略右侧表达式，整个运算符结果为假。如果左侧表达式评估结果为真，则评估右侧表达式，其结果成为整个运算符的结果。<br />
</div></div>
<h1><a id="id118" name="id118">位OR运算符</a>
</h1><div class="para"><div>
　位OR运算符 <code class="inlinecode"><a id="id119" name="id119" class="targanchor"><dfn>|</dfn></a></code> 进行按位的逻辑OR运算。依次评估左侧表达式和右侧表达式，将其结果作为整数，进行按位OR运算的结果成为整个运算符的值。<br />
</div></div>
<h1><a id="id120" name="id120">位XOR运算符</a>
</h1><div class="para"><div>
　位XOR运算符 <code class="inlinecode"><a id="id121" name="id121" class="targanchor"><dfn>^</dfn></a></code> 进行按位的逻辑XOR运算。依次评估左侧表达式和右侧表达式，将其结果作为整数，进行按位XOR运算的结果成为整个运算符的值。<br />
</div></div>
<h1><a id="id122" name="id122">位AND运算符</a>
</h1><div class="para"><div>
　位AND运算符 <code class="inlinecode"><a id="id123" name="id123" class="targanchor"><dfn>&amp;</dfn></a></code> 进行按位的逻辑AND运算。依次评估左侧表达式和右侧表达式，将其结果作为整数，进行按位AND运算的结果成为整个运算符的值。<br />
</div></div>
<h1><a id="id124" name="id124">同一性运算符</a>
</h1><div class="para"><div>
　<code class="inlinecode"><a id="id125" name="id125" class="targanchor"><dfn>==</dfn></a>  <a id="id126" name="id126" class="targanchor"><dfn>!=</dfn></a>  <a id="id127" name="id127" class="targanchor"><dfn>===</dfn></a>  <a id="id128" name="id128" class="targanchor"><dfn>!==</dfn></a></code>都是同一性运算符的类型。<br />
<br />
<dl>
<dt><code class="inlinecode">==</code> 运算符</dt>
<dd><code class="inlinecode">==</code> 运算符先评估左侧表达式，然后评估右侧表达式。如果两者匹配，则整个运算符为真，不匹配则为假。如果两边运算结果的类型不同，会进行适当转换后再比较。例如，<code class="inlinecode">-1 == '-1'</code>为真。</dd>
<dt><code class="inlinecode">!=</code> 运算符</dt>
<dd><code class="inlinecode">!=</code> 运算符的真假与<code class="inlinecode">==</code>运算符相反。</dd>
<dt><code class="inlinecode">===</code> 运算符</dt>
<dd><code class="inlinecode">===</code> 运算符称为标识比较运算符，与<code class="inlinecode">==</code>运算符相同，但不进行类型转换，必须类型也一致才为真。</dd>
<dt><code class="inlinecode">!==</code> 运算符</dt>
<dd><code class="inlinecode">!==</code> 运算符的真假与<code class="inlinecode">===</code>运算符相反。</dd></dl></div></div>
<h1><a id="id129" name="id129">比较运算符</a>
</h1><div class="para"><div>
　<code class="inlinecode"><a id="id130" name="id130" class="targanchor"><dfn>&lt;</dfn></a>  <a id="id131" name="id131" class="targanchor"><dfn>&gt;</dfn></a>  <a id="id132" name="id132" class="targanchor"><dfn>&lt;=</dfn></a>  <a id="id133" name="id133" class="targanchor"><dfn>&gt;=</dfn></a></code> 是比较运算符的类型。<br />
<br />
<dl>
<dt><code class="inlinecode">&lt;</code> 运算符</dt>
<dd><code class="inlinecode">&lt;</code> 运算符先评估左侧表达式，然后评估右侧表达式。如果左侧评估结果小于右侧评估结果，则为真，否则为假。</dd>
<dt><code class="inlinecode">&gt;</code> 运算符</dt>
<dd><code class="inlinecode">&gt;</code> 运算符先评估左侧表达式，然后评估右侧表达式。如果右侧评估结果小于左侧评估结果，则为真，否则为假。</dd>
<dt><code class="inlinecode">&lt;=</code> 运算符</dt>
<dd><code class="inlinecode">&lt;=</code> 运算符先评估左侧表达式，然后评估右侧表达式。如果左侧评估结果小于或等于右侧评估结果，则为真，否则为假。</dd>
<dt><code class="inlinecode">&gt;=</code> 运算符</dt>
<dd><code class="inlinecode">&gt;=</code> 运算符先评估左侧表达式，然后评估右侧表达式。如果右侧评估结果小于或等于左侧评估结果，则为真，否则为假。</dd></dl><br />
　如果比较的对象都是字符串，则按宽字符代码顺序(通常是UNICODE)进行比较。<br />
</div></div>
<h1><a id="id134" name="id134">位移运算符</a>
</h1><div class="para"><div>
　<code class="inlinecode"><a id="id135" name="id135" class="targanchor"><dfn>&gt;&gt;</dfn></a>  <a id="id136" name="id136" class="targanchor"><dfn>&lt;&lt;</dfn></a>  <a id="id137" name="id137" class="targanchor"><dfn>&gt;&gt;&gt;</dfn></a></code>是位移运算符的类型。<br />
<br />
<dl>
<dt><code class="inlinecode">&gt;&gt;</code> 运算符</dt>
<dd><code class="inlinecode">&gt;&gt;</code> 运算符先评估左侧表达式，然后评估右侧表达式。将左侧结果作为整数，右移右侧结果次数，进行带符号位移，结果成为整个运算符的结果。</dd>
<dt><code class="inlinecode">&lt;&lt;</code> 运算符</dt>
<dd><code class="inlinecode">&lt;&lt;</code> 运算符先评估左侧表达式，然后评估右侧表达式。将左侧结果作为整数，左移右侧结果次数，结果成为整个运算符的结果。</dd>
<dt><code class="inlinecode">&gt;&gt;&gt;</code> 运算符</dt>
<dd><code class="inlinecode">&gt;&gt;&gt;</code> 运算符与<code class="inlinecode">&gt;&gt;</code>运算符相同，但将左侧评估结果作为无符号整数处理。</dd></dl></div></div>
<h1><a id="id138" name="id138">加减运算符</a>
</h1><div class="para"><div>
　<code class="inlinecode"><a id="id139" name="id139" class="targanchor"><dfn>+</dfn></a>  <a id="id140" name="id140" class="targanchor"><dfn>-</dfn></a></code> 分别是加法运算符和减法运算符。<br />
<br />
<dl>
<dt><code class="inlinecode">+</code> 运算符</dt>
<dd><code class="inlinecode">+</code> 运算符先评估左侧表达式，然后评估右侧表达式。如果两者都是数值，则进行数值上的加法，结果成为整个运算符的结果。如果一个或两个都是字符串，则进行字符串加法，整个运算符的结果为左侧结果后面连接右侧结果的字符串。数值可转换为字符串，对象类型如果可以转换为字符串则会转换。</dd>
<dt><code class="inlinecode">-</code> 运算符</dt>
<dd><code class="inlinecode">-</code> 运算符先评估左侧表达式，然后评估右侧表达式。之后，作为数值从左侧结果中减去右侧结果，结果成为整个运算符的值。</dd></dl></div></div>
<h1><a id="id141" name="id141">乘除余运算符</a>
</h1><div class="para"><div>
　<code class="inlinecode"><a id="id142" name="id142" class="targanchor"><dfn>%</dfn></a>  <a id="id143" name="id143" class="targanchor"><dfn>/</dfn></a>  <a id="id144" name="id144" class="targanchor"><dfn>\</dfn></a>  <a id="id145" name="id145" class="targanchor"><dfn>*</dfn></a></code> 分别是取余、除法、整数除法和乘法运算符。<br />
<br />
<dl>
<dt><code class="inlinecode">%</code> 运算符</dt>
<dd><code class="inlinecode">%</code> 运算符先评估左侧表达式，然后评估右侧表达式。之后，左侧除以右侧的余数成为整个运算符的值。值都作为整数处理。</dd>
<dt><code class="inlinecode">/</code> 运算符</dt>
<dd><code class="inlinecode">/</code> 运算符先评估左侧表达式，然后评估右侧表达式。之后，左侧除以右侧的值成为整个运算符的值。值作为实数处理。</dd>
<dt><code class="inlinecode">\</code> 运算符</dt>
<dd><code class="inlinecode">\</code> 运算符和 / 运算符一样进行除法，但值作为整数处理。</dd>
<dt><code class="inlinecode">*</code> 运算符</dt>
<dd><code class="inlinecode">*</code> 运算符先评估左侧表达式，然后评估右侧表达式。之后，左侧乘以右侧的值成为整个运算符的值。值作为实数处理。</dd></dl></div></div>
<h1><a id="id146" name="id146">常见的一元运算符类型</a>
</h1><div class="para"><div>
　以下全部是一元运算符（<code class="inlinecode">instanceof</code>除外）。<br />
<br />
<dl>
<dt><code class="inlinecode"><a id="id147" name="id147" class="targanchor"><dfn>!</dfn></a></code> 运算符</dt>
<dd>前置的<code class="inlinecode">!</code>运算符是逻辑非运算符。将右侧表达式评估结果的真假取反，结果成为整个运算符的值。</dd>
<dt><code class="inlinecode"><a id="id148" name="id148" class="targanchor"><dfn>~</dfn></a></code> 运算符</dt>
<dd><code class="inlinecode">~</code>运算符是位非运算符。将右侧表达式评估结果作为整数，进行按位非运算（1→0，0→1），结果成为整个运算符的值。</dd>
<dt><code class="inlinecode"><a id="id149" name="id149" class="targanchor"><dfn>--</dfn></a></code> 运算符</dt>
<dd>前置的<code class="inlinecode">--</code>运算符是前置<a id="id150" name="id150" class="targanchor"><dfn>递减</dfn></a>运算符。从右侧表达式减去1，减少后的值成为整个运算符的值。</dd>
<dt><code class="inlinecode"><a id="id151" name="id151" class="targanchor"><dfn>++</dfn></a></code> 运算符</dt>
<dd>前置的<code class="inlinecode">++</code>运算符是前置<a id="id152" name="id152" class="targanchor"><dfn>递增</dfn></a>运算符。将右侧表达式加1，加上后的值成为整个运算符的值。</dd>
<dt><code class="inlinecode"><a id="id153" name="id153" class="targanchor"><dfn>new</dfn></a></code> 运算符</dt>
<dd><code class="inlinecode">new</code>运算符使右侧的函数评估表达式不执行函数调用，而是进行对象创建。</dd>
<dt><code class="inlinecode"><a id="id154" name="id154" class="targanchor"><dfn>invalidate</dfn></a> 运算符</code></dt>
<dd><code class="inlinecode">invalidate</code>运算符评估右侧表达式，并使其结果对象无效化。如果右侧表达式是void、字符串、数值或八位字节序列，则不做任何操作。如果对象已经被无效化，也不做任何操作。如果指定了null，则会引发异常。</dd>
<dt><code class="inlinecode"><a id="id155" name="id155" class="targanchor"><dfn>isvalid</dfn></a> 运算符</code></dt>
<dd><code class="inlinecode">isvalid</code>运算符评估右侧或左侧表达式，如果其结果对象有效则返回true，无效则返回false。将运算符放在评估对象的前面或后面意义相同。如果目标是void、字符串、数值或八位字节序列，则始终返回真。如果指定了null，则会引发异常。</dd>
<dt><code class="inlinecode"><a id="id156" name="id156" class="targanchor"><dfn>delete</dfn></a> 运算符</code></dt>
<dd><code class="inlinecode">delete</code>运算符删除右侧所写对象的成员或局部变量。删除成功返回true，失败返回false。</dd>
<dt><code class="inlinecode"><a id="id157" name="id157" class="targanchor"><dfn>typeof</dfn></a> 运算符</code></dt>
<dd><code class="inlinecode">typeof</code>运算符评估右侧表达式，根据其类型返回以下字符串：void:"void"、整数:"Integer"、实数:"Real"、对象:"Object"、字符串:"String"、八位字节序列:"Octet"。不过，指定对象成员且该成员不存在时，返回"undefined"。</dd>
<dt><code class="inlinecode"><a id="id158" name="id158" class="targanchor"><dfn>#</dfn></a> 运算符</code></dt>
<dd><code class="inlinecode">#</code>运算符评估右侧表达式，作为字符串取第一个字符的字符代码作为整个运算符的值。</dd>
<dt><code class="inlinecode"><a id="id159" name="id159" class="targanchor"><dfn>$</dfn></a> 运算符</code></dt>
<dd><code class="inlinecode">$</code>运算符评估右侧表达式，将其结果作为字符代码，转换成表示该字符的一个字符作为整个运算符的值。</dd>
<dt><code class="inlinecode"><a id="id160" name="id160" class="targanchor"><dfn>+</dfn></a> 运算符</code></dt>
<dd>一元的<code class="inlinecode"><a id="id161" name="id161" class="targanchor"><dfn>+</dfn></a></code>运算符评估右侧表达式。如果右侧表达式是实数或整数，则不做任何操作。其他情况下，尝试转换为实数或数值，其结果成为整个运算符的结果。尝试将字符串转换为数值时，如果转换失败，不会引发异常，而是返回0。包含小数点的实数表示会转换为实数，否则转换为整数。字符串开头有0x、0b或0时，分别作为16进制、2进制或8进制解释。</dd>
<dt><code class="inlinecode"><a id="id162" name="id162" class="targanchor"><dfn>-</dfn></a> 运算符</code></dt>
<dd>一元的<code class="inlinecode">-</code>运算符评估左侧表达式，将其结果作为数值取反，结果成为整个运算符的结果。</dd>
<dt><code class="inlinecode"><a id="id163" name="id163" class="targanchor"><dfn>&amp;</dfn></a> 运算符</code></dt>
<dd>一元的<code class="inlinecode">&amp;</code>运算符使右侧对象成员的访问不通过属性处理器，而是直接访问属性对象本身。例如，propobj = &amp;obj.prop; 中，obj的成员属性prop的属性处理器不会启动，而是将成员属性prop的<a id="id164" name="id164" class="targanchor"><dfn>属性对象</dfn></a>本身的引用赋给propobj。如果右侧不是属性访问，其行为是不确定的。</dd>
<dt><code class="inlinecode"><a id="id165" name="id165" class="targanchor"><dfn>*</dfn></a> 运算符</code></dt>
<dd>一元的<code class="inlinecode">*</code>运算符使右侧对象的属性处理器运行。右侧必须写表示属性对象的表达式。例如，*propobj = 1; 调用属性对象propobj的setter处理器，赋值1。</dd>
<dt><code class="inlinecode"><a id="id166" name="id166" class="targanchor"><dfn>instanceof</dfn></a> 运算符</code></dt>
<dd><code class="inlinecode">instanceof</code>运算符先评估左侧表达式，然后评估右侧表达式。右侧应写能转换为字符串的类名，如果左侧是该类的实例则返回true，否则返回false。</dd></dl></div></div>
<h1><a id="id167" name="id167">函数调用、括号类、后置递增递减等</a>
</h1><div class="para"><div>
<dl>
<dt><code class="inlinecode"><a id="id168" name="id168" class="targanchor"><dfn>(  )</dfn></a> 运算符</code></dt>
<dd><code class="inlinecode">(  )</code>运算符用于改变运算优先级，或者进行函数调用。</dd>
<dt><code class="inlinecode"><a id="id169" name="id169" class="targanchor"><dfn>[  ]</dfn></a> 运算符</code></dt>
<dd><code class="inlinecode">[  ]</code>运算符是间接成员选择运算符。在<code class="inlinecode">A [ B ]</code>形式中，先评估A，然后评估B。将B作为字符串，在A中查找该成员名，整个运算符作为对该成员的访问。当作为左值使用时，还会在对象中创建成员B，如果不存在则新建。</dd>
<dt><code class="inlinecode"><a id="id170" name="id170" class="targanchor"><dfn>.</dfn></a> 运算符</code></dt>
<dd><code class="inlinecode">.</code>运算符是直接成员选择运算符。在<code class="inlinecode">A.B</code>形式中，评估A。在A中查找B，整个运算符作为对该成员的访问。当作为左值使用时，还会在对象中创建成员B，如果不存在则新建。<br />
如果<code class="inlinecode">.</code>运算符的左侧被省略，则在with语句外部引用global对象中的成员，在with语句内部引用该with指定对象的成员。</dd>
<dt><code class="inlinecode"><a id="id171" name="id171" class="targanchor"><dfn>++</dfn></a> 运算符</code></dt>
<dd>后置的<code class="inlinecode">++</code>运算符是后置递增运算符。将左侧表达式加1，整个运算符的值为加法前的左侧表达式值。</dd>
<dt><code class="inlinecode"><a id="id172" name="id172" class="targanchor"><dfn>--</dfn></a> 运算符</code></dt>
<dd>后置的<code class="inlinecode">--</code>运算符是后置递减运算符。从左侧表达式减去1，整个运算符的值为减法前的左侧表达式值。</dd>
<dt><code class="inlinecode"><a id="id173" name="id173" class="targanchor"><dfn>!</dfn></a> 运算符</code></dt>
<dd>后置的<code class="inlinecode">!</code>运算符是表达式评估运算符。将左侧表达式评估结果作为字符串，将其解释为表达式字符串。结果是对该表达式字符串解释和评估的结果。表达式在this上下文（使用此运算符的位置的this）中运行。</dd>
<dt><code class="inlinecode"><a id="id174" name="id174" class="targanchor"><dfn>incontextof</dfn></a> 运算符</code></dt>
<dd><code class="inlinecode">incontextof</code>运算符先评估左侧表达式，然后评估右侧表达式。将左侧评估结果作为对象，用右侧评估结果替换该对象的上下文部分，替换后的对象成为整个运算的结果。</dd>
<dt><code class="inlinecode"><a id="id175" name="id175" class="targanchor"><dfn>int</dfn></a> 运算符</code></dt>
<dd>int运算符评估右侧表达式，将其转换为整数类型的结果成为整个运算符的结果。也可以像C语言中的强制类型转换一样写作(int)。</dd>
<dt><code class="inlinecode"><a id="id176" name="id176" class="targanchor"><dfn>real</dfn></a> 运算符</code></dt>
<dd>real运算符评估右侧表达式，将其转换为实数类型的结果成为整个运算符的结果。也可以像C语言中的强制类型转换一样写作(real)。</dd>
<dt><code class="inlinecode"><a id="id177" name="id177" class="targanchor"><dfn>string</dfn></a> 运算符</code></dt>
<dd>string运算符评估右侧表达式，将其转换为字符串类型的结果成为整个运算符的结果。也可以像C语言中的强制类型转换一样写作(string)。</dd></dl></div></div>
	<script type="text/javascript" charset="UTF-8" src="documentid.js" ></script>
	<script type="text/javascript" charset="UTF-8" src="postcontent.js" ></script>
</body>
</html>
