<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html  xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh">
<!-- generated by to_html.pl from class.xml -->
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<title>类</title>
	<meta name="author" content="W.Dee" />
	<meta http-equiv="Content-Style-Type" content="text/css" />
	<meta http-equiv="Content-Script-Type" content="text/javascript" />
	<link href="browser.css" type="text/css" rel="stylesheet" title="吉里吉里相关参考标准样式" />
	<link href="mailto:dee@kikyou.info" rev="Made" />
	<link href="index.html" target="_top" rel="Start" title="首页" />
</head>
<body>
<h1><a id="id47" name="id47">类</a>
</h1><div class="para"><div>
　类是创建对象时的模板。类中的变量称为成员变量，类中的函数称为成员函数或方法，类中的属性称为成员属性。<br />
<br />
　类基本上是以下面这种方式声明的。<br />

<br />
<code class="bq"><a id="id48" name="id48" class="targanchor"><dfn>class</dfn></a>&nbsp;classname<br />
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;描述成员、成员方法和成员属性</span><br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;classname()&nbsp;<span class="comment">//&nbsp;构造函数</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;<a id="id49" name="id49" class="targanchor"><dfn>finalize</dfn></a>()<br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
}<br />
<br />
</code>
<br />

<br />
　类名应指定为标识符。<br />
<br />
　在类中，描述当该类被创建时将成为成员的变量、方法和属性。<br />
<br />
　类中必须有一个与类同名的方法，称为<a id="id50" name="id50" class="targanchor"><dfn>构造函数</dfn></a>。当使用<a id="id51" name="id51" class="targanchor"><dfn>new</dfn></a>运算符创建对象时，会调用这个函数，并传入new运算符的参数。<br />
<br />
　类中还有一个名为finalize的特殊方法，这是对象消亡时调用的方法，可以省略。可以不写。<br />
<br />

<br />
<code class="bq"><span class="weak">例:</span><br />&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;test<br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;test()<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;构造函数</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;在这里写对象创建时要处理的内容</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;variable&nbsp;=&nbsp;0;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;finalize()<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;finalize&nbsp;方法</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;在这里写对象销毁时要处理的内容</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;method1()<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;方法</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.inform(variable);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;variable;&nbsp;<span class="comment">//&nbsp;成员变量</span><br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;property&nbsp;prop&nbsp;<span class="comment">//&nbsp;成员属性</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getter()&nbsp;{&nbsp;return&nbsp;variable;&nbsp;}&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
</code>
<br />

<br />
对类使用instanceof运算符并带上"Class"时会返回真（在上述例子中，test instanceof "Class"为真）。<br />
</div></div>
<h1><a id="id52" name="id52">创建对象</a>
</h1><div class="para"><div>
　要创建已声明类的对象，请使用new运算符。<br />
　在new运算符后面，与函数调用类似，指定类名和要传递给构造函数的参数。<br />

<br />
<code class="bq"><span class="weak">例:</span><br />&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Test<br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;variable1&nbsp;=&nbsp;getValue();&nbsp;<span class="comment">//&nbsp;初始化成员变量</span><br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;Test(arg1,&nbsp;arg2)&nbsp;<span class="comment">//&nbsp;构造函数</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;这里new运算符指定的参数被传递给arg1和arg2</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;newobject&nbsp;=&nbsp;new&nbsp;Test(1,&nbsp;2);&nbsp;<span class="comment">//&nbsp;创建test类的对象，并传递参数1和2</span><br />
</code>
<br />

<br />
　类创建时的处理顺序如下：<br />
<br />
<ol><li>首先创建一个空对象</li><li>注册方法和属性</li><li>创建成员变量（需要初始化的变量将被初始化）</li><li>执行构造函数</li></ol><br /><div class="note"><div class="notehead"><span class="noteheadspan">注意</span></div>
　即使构造函数没有参数，也不能省略new运算符的()。不能像JavaScript那样写new Test，必须写new Test()。<br />
</div><br />
<br />
　特别是，在类的方法或属性中创建该类的对象，或创建该类的超类对象时，如下写法会导致错误：<br />

<br />
<code class="bq"><span class="weak">例:</span><br />&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Test<br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;Test()&nbsp;<span class="comment">//&nbsp;构造函数</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;func()<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;Test();&nbsp;<span class="comment">//&nbsp;错误</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
</code>
<br />

<br />
　这是因为在类的方法或属性中简单地写Test时，由于构造函数Test比类Test在作用域上更近，所以会引用构造函数Test而不是类Test。在这种情况下，为了避免这个问题，需要使用global.明确指定，如下所示（因为类是注册在global中的）。<br />
<br />

<br />
<code class="bq"><span class="weak">例:</span><br />&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Test<br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;Test()&nbsp;<span class="comment">//&nbsp;构造函数</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;func()<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;global.Test();&nbsp;<span class="comment">//&nbsp;这样就可以了</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
</code>
<br />

</div></div>
<h1><a id="id53" name="id53">对象的无效化</a>
</h1><div class="para"><div>
　在TJS2中，当对象被删除时，会经过对象的<a id="id54" name="id54" class="targanchor"><dfn>无效化</dfn></a>和对象的删除两个阶段。<br />
　当对象被无效化时，会调用finalize方法，并给该对象标记为无效。此后，所有对该对象的访问都将失败，并引发异常。可以使用<a id="id55" name="id55" class="targanchor"><dfn>isvalid</dfn></a>运算符检查对象是否已被无效化。<br />
<br />
　可以使用<a id="id56" name="id56" class="targanchor"><dfn>invalidate</dfn></a>运算符使对象无效。<br />
<br />

<br />
<code class="bq"><span class="weak">例:</span><br />&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Test<br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;variable;<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;Test()<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;构造函数</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;variable&nbsp;=&nbsp;new&nbsp;AnotherClass();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;finalize()<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;finalize方法在对象被无效化时调用</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invalidate&nbsp;variable;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;object&nbsp;=&nbsp;new&nbsp;Test();&nbsp;<span class="comment">//&nbsp;创建对象</span><br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;(略)<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;invalidate&nbsp;object;&nbsp;<span class="comment">//&nbsp;使对象无效</span><br />
</code>
<br />

<br />
　即使不使用invalidate运算符，对象在不再需要时也会被删除。这时，如果它没有被无效化，将在删除时被无效化。<br />
　在TJS2中，没有明确规定什么时候对象会被删除，所以删除和无效化"随时可能发生"。因此，由于未被无效化的对象会在删除时被无效化，finalize方法可能会在意外的时间点被调用。为了避免这种情况，建议在使用完对象后使用invalidate运算符使其无效。<br />
<br />
<br /><div class="note"><div class="notehead"><span class="noteheadspan">注意</span></div>
　invalidate运算符的功能类似于C++的delete运算符。<br />
　TJS2的delete运算符与C++的delete运算符不同，它是用于删除成员或局部变量的运算符。它不会使对象本身无效或删除，但删除成员或局部变量可能会导致对象的无效化或删除。<br />
</div><br />
</div></div>
<h1><a id="id57" name="id57">访问对象</a>
</h1><div class="para"><div>
　要访问创建的对象的成员变量、方法和成员属性，请使用<a id="id58" name="id58" class="targanchor"><dfn>.</dfn></a>（成员选择）运算符或<a id="id59" name="id59" class="targanchor"><dfn>[ ]</dfn></a>（间接成员选择）运算符。<br />

<br />
<code class="bq"><span class="weak">例:</span><br />&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;obj=new&nbsp;MyLayer(window,window.prmaryLayer)<br />
&nbsp;&nbsp;&nbsp;&nbsp;obj.method1();&nbsp;<span class="comment">//&nbsp;调用方法  使用obj['method1']()也一样</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;obj.num&nbsp;=&nbsp;3;&nbsp;<span class="comment">//&nbsp;给成员变量赋值  使用obj['num']=3也一样</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;obj.prop1++;&nbsp;<span class="comment">//&nbsp;访问成员属性  使用obj['prop1']++也一样</span><br />
</code>
<br />

</div></div>
<h1><a id="id60" name="id60">闭包</a>
</h1><div class="para"><div>
　创建的对象的方法和成员属性在注册到对象时，会保持该成员属于哪个对象的信息。<br />
　因此，即使将方法或成员属性带出对象外部并使用，仍然会对原始对象进行访问。这个功能称为闭包。访问的目标对象称为<a id="id61" name="id61" class="targanchor"><dfn>上下文</dfn></a>。<br />

<br />
<code class="bq"><span class="weak">例:</span><br />&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;obj&nbsp;=&nbsp;new&nbsp;FooBarClass();&nbsp;<span class="comment">//&nbsp;创建对象</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;obj.method();&nbsp;<span class="comment">//&nbsp;正常调用对象的方法</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;objmethod&nbsp;=&nbsp;obj.method;&nbsp;<span class="comment">//&nbsp;将对象方法的引用赋值给objmethod</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;objmethod();&nbsp;<span class="comment">//&nbsp;调用objmethod，但和obj.method()一样，是对obj的访问</span><br />
</code>
<br />

<br />
　<a id="id62" name="id62" class="targanchor"><dfn>incontextof</dfn></a>运算符提供了更改"哪个对象的成员"信息的方法，允许在任意上下文中执行方法。<br />

<br />
<code class="bq"><span class="weak">例:</span><br />&nbsp;&nbsp;&nbsp;&nbsp;(objmethod&nbsp;incontextof&nbsp;obj2)();&nbsp;<span class="comment">//&nbsp;变成对obj2的操作</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;(objmethod&nbsp;incontextof&nbsp;this)();&nbsp;<span class="comment">//&nbsp;变成对this的操作</span></code>
<br />

</div></div>

<h1><a id="id63" name="id63">继承</a>
</h1><div class="para"><div>
　使用关键字<a id="id64" name="id64" class="targanchor"><dfn>extends</dfn></a>可以让一个类从另一个类继承。继承意味着继承原始类的成员。<br />
　被继承的类称为<a id="id65" name="id65" class="targanchor"><dfn>超类</dfn></a>，继承的类称为<a id="id66" name="id66" class="targanchor"><dfn>子类</dfn></a>。<br />
　类的声明如下所示：<br />

<br />
<code class="bq"><span class="weak">例:</span><br />&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Class1&nbsp;<span class="comment">//&nbsp;超类</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;Class1()&nbsp;<span class="comment">//&nbsp;Class1构造函数</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;finalize()&nbsp;<span class="comment">//&nbsp;Class1 finalize</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;method1()&nbsp;<span class="comment">//&nbsp;method1</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Class2&nbsp;extends&nbsp;Class1<br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;Class2()&nbsp;<span class="comment">//&nbsp;Class2构造函数</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.Class1();&nbsp;<span class="comment">//&nbsp;调用Class1构造函数</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;finalize()&nbsp;<span class="comment">//&nbsp;Class2 finalize</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.finalize();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;obj&nbsp;=&nbsp;new&nbsp;Class2();&nbsp;<span class="comment">//&nbsp;创建Class2对象</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;obj.method1();&nbsp;<span class="comment">//&nbsp;由于Class2继承了Class1的method1，所以可以使用</span><br />
</code>
<br />

　在上面的例子中，Class2继承了Class1。也可以说Class2<a id="id67" name="id67" class="targanchor"><dfn>派生</dfn></a>自Class1。<br />
　在Class2的构造函数中调用了Class1的构造函数，在Class2的finalize中调用了Class1的finalize。<em>如果子类在这些方法中不调用超类的相应方法，行为是未定义的</em>（或者说，当前版本没有检查是否调用），所以请务必编写这些调用。<br />
<br />
　要从子类引用超类，可以像上面例子中那样使用关键字<a id="id68" name="id68" class="targanchor"><dfn>super</dfn></a>。这个关键字只能在子类中使用，表示超类。<br />
<br />
　在有继承的情况下，使用new运算符初始化对象的顺序如下：<br />
<br />
<ol><li>首先创建一个空对象</li><li>注册方法和属性（从超类开始，向子类方向）</li><li>创建成员变量（从超类开始，向子类方向）</li><li>调用子类的构造函数</li><li>（从子类构造函数中）调用超类的构造函数</li></ol></div></div>
<h1><a id="id69" name="id69">多重继承</a>
</h1><div class="para"><div>
　在extends后面列出多个超类名可以实现多重继承。<br />

<br />
<code class="bq"><span class="weak">例:</span><br />&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;SubClass&nbsp;extends&nbsp;ClassA,&nbsp;ClassB<br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;SubClass()&nbsp;<span class="comment">//&nbsp;SubClass构造函数</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ClassA();&nbsp;<span class="comment">//&nbsp;调用ClassA构造函数</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ClassB();&nbsp;<span class="comment">//&nbsp;调用ClassB构造函数</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;finalize()&nbsp;<span class="comment">//&nbsp;Class2 finalize</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;global.ClassA.finalize();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;global.ClassB.finalize();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
</code>
<br />

　由于不能使用super关键字，必须明确指定类。在调用超类方法时故意加上global.前缀是因为在子类中简单地写ClassA会指向ClassA的构造函数。由于类本身是注册在global中的，所以用global.来访问类。<br />
<br />
　在多重继承的情况下，用new运算符初始化对象的顺序与没有多重继承时相同，但超类的方法和属性的注册顺序取决于extends关键字后面列出的顺序。如果继承的类之间有同名的方法或属性，后面列出的类会优先。可以通过明确指定类名（如global.ClassA.hiddenMethod()）来访问被隐藏的方法或属性。<br />
</div></div>
<h1><a id="id70" name="id70">重写</a>
</h1><div class="para"><div>
　如果在子类中声明与超类方法或成员属性同名的方法或属性，可以隐藏超类的方法。这称为重写。<br />
　上述说明中提到的finalize方法就是重写超类的finalize方法的例子。<br />

<br />
<code class="bq"><span class="weak">例:</span><br />&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Class1&nbsp;<span class="comment">//&nbsp;超类</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;Class1()&nbsp;<span class="comment">//&nbsp;Class1构造函数</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;finalize()&nbsp;<span class="comment">//&nbsp;Class1 finalize</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;method1()&nbsp;<span class="comment">//&nbsp;method1</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(略)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Class2&nbsp;extends&nbsp;Class1<br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;Class2()&nbsp;<span class="comment">//&nbsp;Class2构造函数</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.Class1();&nbsp;<span class="comment">//&nbsp;调用Class1构造函数</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;finalize()&nbsp;<span class="comment">//&nbsp;Class2 finalize</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.finalize();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;method1()&nbsp;<span class="comment">//&nbsp;重写Class1.method1</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(略)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(略)&nbsp;return&nbsp;super.method1();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(略)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;obj&nbsp;=&nbsp;new&nbsp;Class2();&nbsp;<span class="comment">//&nbsp;创建Class2对象</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;obj.method1();&nbsp;<span class="comment">//&nbsp;调用Class2的method1</span><br />
</code>
<br />

　在子类的方法或属性中，可以使用super关键字访问超类的方法或属性。<br />
<br />
　不能重写成员变量。成员变量是注册到一个对象的，所以如果子类和超类有同名的成员变量，子类的变量会覆盖超类的变量。<br />
</div></div>
	<script type="text/javascript" charset="UTF-8" src="documentid.js" ></script>
	<script type="text/javascript" charset="UTF-8" src="postcontent.js" ></script>
</body>
</html>
